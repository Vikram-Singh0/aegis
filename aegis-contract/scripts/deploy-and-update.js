const { ethers } = require("hardhat");
const fs = require("fs");
const path = require("path");

async function main() {
  const signers = await ethers.getSigners();
  const deployer = signers[0];
  const user1 = signers[1];
  const user2 = signers[2];
  console.log("Deploying contracts with account:", deployer.address);
  console.log("Account balance:", ethers.formatEther(await deployer.provider.getBalance(deployer.address)));

  // 1. Deploy WETH-Test
  const WETH = await ethers.getContractFactory("WETHTest");
  const weth = await WETH.deploy(ethers.parseEther("1000000")); // 1M supply
  await weth.waitForDeployment();
  console.log("‚úÖ WETH-Test deployed at:", await weth.getAddress());

  // 2. Deploy USDC-Test
  const USDC = await ethers.getContractFactory("USDCTest");
  const usdc = await USDC.deploy(ethers.parseEther("1000000")); // 1M supply
  await usdc.waitForDeployment();
  console.log("‚úÖ USDC-Test deployed at:", await usdc.getAddress());

  // 3. Deploy RiskBounds
  const RiskBounds = await ethers.getContractFactory("RiskBounds");
  const riskBounds = await RiskBounds.deploy();
  await riskBounds.waitForDeployment();
  console.log("‚úÖ RiskBounds deployed at:", await riskBounds.getAddress());

  // 4. Deploy CollateralManager
  const CollateralManager = await ethers.getContractFactory("CollateralManager");
  const manager = await CollateralManager.deploy(
    await weth.getAddress(),
    await usdc.getAddress(),
    ethers.parseEther("2000"), // WETH price
    ethers.parseEther("1"),    // USDC price
    ethers.parseEther("0.6"),  // 60% collateral factor
    ethers.parseEther("0.8"),  // 80% liquidation threshold
    await riskBounds.getAddress()
  );
  await manager.waitForDeployment();
  console.log("‚úÖ CollateralManager deployed at:", await manager.getAddress());

  // 5. Deploy MockPriceOracle
  const MockPriceOracle = await ethers.getContractFactory("MockPriceOracle");
  const oracle = await MockPriceOracle.deploy();
  await oracle.waitForDeployment();
  console.log("‚úÖ MockPriceOracle deployed at:", await oracle.getAddress());

  // 6. Set up oracle in CollateralManager
  await manager.connect(deployer).setOracle(await oracle.getAddress());
  console.log("‚úÖ Oracle set in CollateralManager");

  // 7. Set initial prices in oracle
  await oracle.connect(deployer).setPrice(await weth.getAddress(), ethers.parseEther("2000"));
  await oracle.connect(deployer).setPrice(await usdc.getAddress(), ethers.parseEther("1"));
  console.log("‚úÖ Initial prices set in oracle");

  // 8. Fund users with tokens for testing (if additional signers exist)
  const userFunding = ethers.parseEther("1000");
  if (user1 && user1.address) {
    await weth.transfer(user1.address, userFunding);
    await usdc.transfer(user1.address, userFunding);
  }
  if (user2 && user2.address) {
    await weth.transfer(user2.address, userFunding);
    await usdc.transfer(user2.address, userFunding);
  }
  if (user1 && user2) {
    console.log("‚úÖ Users funded with test tokens");
  } else {
    console.log("‚ÑπÔ∏è  Skipping user1/user2 funding: only one account configured. Your connected wallet (deployer) holds tokens.");
  }

  // 9. Fund the CollateralManager pool with USDC for borrowing
  const poolFunding = ethers.parseEther("100000");
  await usdc.transfer(await manager.getAddress(), poolFunding);
  console.log("‚úÖ CollateralManager pool funded with USDC");

  // 10. Update frontend configuration
  const contractAddresses = {
    COLLATERAL_MANAGER: await manager.getAddress(),
    USER_VAULT: "0x0000000000000000000000000000000000000000", // Will be deployed per user
    WETH: await weth.getAddress(),
    USDC: await usdc.getAddress(),
    PRICE_ORACLE: await oracle.getAddress(),
    RISK_BOUNDS: await riskBounds.getAddress(),
  };

  // Update the frontend config file
  const configPath = path.join(__dirname, "../../src/config/contracts.ts");
  const configContent = `// Contract configuration for Aegis protocol
// Auto-generated by deployment script

export const CONTRACT_CONFIG = {
  // Somnia Testnet addresses (update these after deployment)
  SOMNIA_TESTNET: {
    COLLATERAL_MANAGER: "${contractAddresses.COLLATERAL_MANAGER}",
    USER_VAULT: "${contractAddresses.USER_VAULT}",
    WETH: "${contractAddresses.WETH}",
    USDC: "${contractAddresses.USDC}",
    PRICE_ORACLE: "${contractAddresses.PRICE_ORACLE}",
    RISK_BOUNDS: "${contractAddresses.RISK_BOUNDS}",
  },
  
  // Local development addresses (for testing)
  LOCAL: {
    COLLATERAL_MANAGER: "${contractAddresses.COLLATERAL_MANAGER}",
    USER_VAULT: "${contractAddresses.USER_VAULT}",
    WETH: "${contractAddresses.WETH}",
    USDC: "${contractAddresses.USDC}",
    PRICE_ORACLE: "${contractAddresses.PRICE_ORACLE}",
    RISK_BOUNDS: "${contractAddresses.RISK_BOUNDS}",
  },
  
  // Production addresses (update when deploying to mainnet)
  SOMNIA_MAINNET: {
    COLLATERAL_MANAGER: "0x...", // Replace with mainnet address
    USER_VAULT: "0x...", // Replace with mainnet address
    WETH: "0x...", // Replace with mainnet address
    USDC: "0x...", // Replace with mainnet address
    PRICE_ORACLE: "0x...", // Replace with mainnet address
    RISK_BOUNDS: "0x...", // Replace with mainnet address
  }
} as const;

// Get the current network configuration
export function getContractAddresses() {
  const network = process.env.NEXT_PUBLIC_NETWORK || 'SOMNIA_TESTNET';
  
  switch (network) {
    case 'LOCAL':
      return CONTRACT_CONFIG.LOCAL;
    case 'SOMNIA_MAINNET':
      return CONTRACT_CONFIG.SOMNIA_MAINNET;
    case 'SOMNIA_TESTNET':
    default:
      return CONTRACT_CONFIG.SOMNIA_TESTNET;
  }
}

// Export the current contract addresses
export const CONTRACT_ADDRESSES = getContractAddresses();
`;

  fs.writeFileSync(configPath, configContent);
  console.log("‚úÖ Frontend configuration updated");

  console.log("\nüéâ Deployment complete!");
  console.log("=====================================");
  console.log("Contract Addresses:");
  console.log("WETH:", contractAddresses.WETH);
  console.log("USDC:", contractAddresses.USDC);
  console.log("CollateralManager:", contractAddresses.COLLATERAL_MANAGER);
  console.log("MockPriceOracle:", contractAddresses.PRICE_ORACLE);
  console.log("RiskBounds:", contractAddresses.RISK_BOUNDS);
  console.log("=====================================");
  console.log("User Addresses:");
  console.log("Deployer:", deployer.address);
  if (user1 && user1.address) {
    console.log("User1:", user1.address);
  } else {
    console.log("User1: <not available>");
  }
  if (user2 && user2.address) {
    console.log("User2:", user2.address);
  } else {
    console.log("User2: <not available>");
  }
  console.log("=====================================");
  console.log("Configuration:");
  console.log("WETH Price (Oracle): $2000");
  console.log("USDC Price (Oracle): $1");
  console.log("Collateral Factor: 60%");
  console.log("Liquidation Threshold: 80%");
  console.log("Oracle Integration: Enabled");
  console.log("=====================================");
  console.log("Next Steps:");
  console.log("1. Update NEXT_PUBLIC_NETWORK in .env to 'LOCAL' for local testing");
  console.log("2. Start the frontend: cd ../aegis && npm run dev");
  console.log("3. Connect your wallet and test the lending functionality");
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});

